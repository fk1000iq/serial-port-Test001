2024 07 24
	当前进度：
		串口可以开启/关闭，可以发送数据
		* 串口接收未调试
		发送 ASCII/HEX变换还没有完善，有错误

		发送数据在接收窗口有记录，但是刷新还是有闪烁，这个后期优化
		可以定时发送，并修改发送间隔，间隔较长的，已增加首次按键即发送（不用等定时到，这样比较符合逻辑）

		*文字链接 还未调试


逻辑约定：
	接收区 ASCII/HEX 只能切换 接收到的数据； 不能切换发送区的数据


	关于HEX/ASCII 转换的问题：
	发送区：
		ASCII状态下输入无限制，转换比较简单

		HEX状态下，输入仅限 a~f 或 A~F， 数字 空格等
		且一般字符间是有空格的，用户在输入时，没有输入空格，在切换显示的时候需要做识别，自动添加空格，对于单个字符前面补0

			hex:	"30 31 32323"
		--> 转ASCII:	"0122<03>"    注意这里的尖括号是没有的，是要找 03对应的ASCII来填充
		-->	再转hex: "30 31 32 32 03"

		hex： 发送区"31 32 33 34 35 36 32 32 32 15021"
			实际发出"31 32 33 34 35 36 32 32 32 15 02 01 "
		
		接收区显示：
			[2024-07-25 09:58:20.097]# SEND HEX/12 to COM9 >>>
			31 32 33 34 35 36 32 32 32 15 02 01 
			[2024-07-25 09:58:20.149]# RECV ASCII/12 from COM9 <<<
			123456222												这里显示和串口有点差异
			[2024-07-25 09:59:31.606]# SEND HEX/12 to COM9 >>>
			31 32 33 34 35 36 32 32 32 15 02 01 
			[2024-07-25 09:59:31.659]# RECV HEX/12 from COM9 <<<
			31 32 33 34 35 36 32 32 32 15 02 01 

	----------------------------
	串口处理：
		串口接口函数式发送 string 类型的数据，因此发送需要转为 string 类型

	发送：
		ASCII状态：   
			直接发

		HEX状态： 
			转为标准化HEX数据（需要识别是否空格填充完整，且字节需要补齐的（对于半个字节的））
			然后转为ASCII数据（去掉空格），再发送	
	信息打印：
		ASCII状态：
			加时间戳 + 辅助文字 + 长度（ASCII实际长度） + 原始ASCII数据
			
		HEX状态：
			加时间戳 + 辅助文字 + 长度（转ASCII后的实际数据长度） + 标准化的HEX数据（加间隔，补齐）
		




	发送：
		发送区 ASCII/HEX 控制:（控制本区数据格式，以及发送区记录的格式）
			1.发送区的内容切换
			2.发送出去的数据，在接收区的记录，保持和发送区当前的显示一致
		
		接收区 ASCII/HEX控制：（控制收到数据的格式显示，不能控制发送数据的格式）
			1. 不能修改发送数据的格式
			2. 可以修改收到数据的数据显示格式